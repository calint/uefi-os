#include <efi.h>

const uint8_t ASCII_FONT[128][8] = {
    [0x20] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // Space
    [0x21] = {0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00}, // !
    [0x22] = {0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00}, // "
    [0x23] = {0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00}, // #
    [0x24] = {0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00}, // $
    [0x25] = {0x00, 0x66, 0x6C, 0x18, 0x36, 0x66, 0x00, 0x00}, // %
    [0x26] = {0x38, 0x6C, 0x38, 0x76, 0x6C, 0x6C, 0x3B, 0x00}, // &
    [0x27] = {0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00}, // '
    [0x28] = {0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00}, // (
    [0x29] = {0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00}, // )
    [0x2A] = {0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00}, // *
    [0x2B] = {0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00}, // +
    [0x2C] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30}, // ,
    [0x2D] = {0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00}, // -
    [0x2E] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00}, // .
    [0x2F] = {0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00}, // /
    [0x30] = {0x3C, 0x66, 0x6E, 0x7E, 0x76, 0x66, 0x3C, 0x00}, // 0
    [0x31] = {0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00}, // 1
    [0x32] = {0x3C, 0x66, 0x06, 0x0C, 0x18, 0x30, 0x7E, 0x00}, // 2
    [0x33] = {0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00}, // 3
    [0x34] = {0x0C, 0x1C, 0x3C, 0x6C, 0x7E, 0x0C, 0x0C, 0x00}, // 4
    [0x35] = {0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00}, // 5
    [0x36] = {0x1C, 0x30, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00}, // 6
    [0x37] = {0x7E, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00}, // 7
    [0x38] = {0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00}, // 8
    [0x39] = {0x3C, 0x66, 0x66, 0x3E, 0x06, 0x0C, 0x38, 0x00}, // 9
    [0x3A] = {0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00}, // :
    [0x3B] = {0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30, 0x00}, // ;
    [0x3C] = {0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00}, // <
    [0x3D] = {0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00}, // =
    [0x3E] = {0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x00}, // >
    [0x3F] = {0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x18, 0x00}, // ?
    [0x40] = {0x3C, 0x66, 0x6E, 0x6E, 0x60, 0x62, 0x3C, 0x00}, // @
    [0x41] = {0x18, 0x3C, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00}, // A
    [0x42] = {0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00}, // B
    [0x43] = {0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00}, // C
    [0x44] = {0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00}, // D
    [0x45] = {0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x7E, 0x00}, // E
    [0x46] = {0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x00}, // F
    [0x47] = {0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00}, // G
    [0x48] = {0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00}, // H
    [0x49] = {0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}, // I
    [0x4A] = {0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00}, // J
    [0x4B] = {0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00}, // K
    [0x4C] = {0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00}, // L
    [0x4D] = {0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00}, // M
    [0x4E] = {0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00}, // N
    [0x4F] = {0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00}, // O
    [0x50] = {0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00}, // P
    [0x51] = {0x3C, 0x66, 0x66, 0x66, 0x6E, 0x3C, 0x0E, 0x00}, // Q
    [0x52] = {0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x00}, // R
    [0x53] = {0x3C, 0x66, 0x30, 0x18, 0x0C, 0x66, 0x3C, 0x00}, // S
    [0x54] = {0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00}, // T
    [0x55] = {0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00}, // U
    [0x56] = {0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00}, // V
    [0x57] = {0x63, 0x63, 0x63, 0x6B, 0x7F, 0x7F, 0x63, 0x00}, // W
    [0x58] = {0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00}, // X
    [0x59] = {0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x00}, // Y
    [0x5A] = {0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00}, // Z
    [0x5B] = {0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00}, // [
    [0x5C] = {0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00}, // \
    [0x5D] = {0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00}, // ]
    [0x5E] = {0x18, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00}, // ^
    [0x5F] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00}, // _
    [0x61] = {0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, 0x00}, // a
    [0x62] = {0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00}, // b
    [0x63] = {0x00, 0x00, 0x3C, 0x60, 0x60, 0x66, 0x3C, 0x00}, // c
    [0x64] = {0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00}, // d
    [0x65] = {0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00}, // e
    [0x66] = {0x1C, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x30, 0x00}, // f
    [0x67] = {0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x3C}, // g
    [0x68] = {0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00}, // h
    [0x69] = {0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00}, // i
    [0x6A] = {0x06, 0x00, 0x06, 0x06, 0x06, 0x66, 0x3C, 0x00}, // j
    [0x6B] = {0x60, 0x60, 0x6C, 0x78, 0x70, 0x6C, 0x66, 0x00}, // k
    [0x6C] = {0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}, // l
    [0x6D] = {0x00, 0x00, 0x66, 0x7F, 0x7F, 0x6B, 0x63, 0x00}, // m
    [0x6E] = {0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00}, // n
    [0x6F] = {0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00}, // o
    [0x70] = {0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60}, // p
    [0x71] = {0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x06}, // q
    [0x72] = {0x00, 0x00, 0x7C, 0x66, 0x60, 0x60, 0x60, 0x00}, // r
    [0x73] = {0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x00}, // s
    [0x74] = {0x30, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x1C, 0x00}, // t
    [0x75] = {0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00}, // u
    [0x76] = {0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00}, // v
    [0x77] = {0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x63, 0x00}, // w
    [0x78] = {0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00}, // x
    [0x79] = {0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x3C}, // y
    [0x7A] = {0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x00}, // z
    [0x7B] = {0x0C, 0x18, 0x18, 0x30, 0x18, 0x18, 0x0C, 0x00}, // {
    [0x7C] = {0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00}, // |
    [0x7D] = {0x30, 0x18, 0x18, 0x0C, 0x18, 0x18, 0x30, 0x00}, // }
    [0x7E] = {0x00, 0x00, 0x3B, 0x6E, 0x00, 0x00, 0x00, 0x00}, // ~
};

void draw_char(UINT32* fb, UINT32 x, UINT32 y, char c, UINT32 color,
               UINT32 stride) {
    if (c < 32 || c > 126) {
        c = '?'; // fallback
    }
    const uint8_t* glyph = ASCII_FONT[(uint8_t)c];
    for (int i = 0; i < 8; ++i) {
        for (int j = 0; j < 8; ++j) {
            if (glyph[i] & (1 << (7 - j))) {
                fb[(y + i) * stride + (x + j)] = color;
            }
        }
    }
}

void print_string(UINT32* fb, UINT32 x, UINT32 y, const char* str, UINT32 color,
                  UINT32 stride) {
    for (int i = 0; str[i] != '\0'; ++i) {
        draw_char(fb, x + (i * 8), y, str[i], color, stride);
    }
}

void print_hex_screen(UINT32* fb, UINT32 x, UINT32 y, UINT64 val, UINT32 color,
                      UINT32 stride) {
    char hex_chars[] = "0123456789ABCDEF";
    print_string(fb, x, y, "0x", color, stride);
    for (int i = 0; i < 16; i++) {
        draw_char(fb, x + 16 + (i * 8), y,
                  hex_chars[(val >> (60 - i * 4)) & 0xF], color, stride);
    }
}

void outb(UINT16 port, UINT8 val) {
    __asm__ volatile("outb %0, %1" : : "a"(val), "Nd"(port));
}

void print_serial(const char* s) {
    while (*s)
        outb(0x3F8, *s++);
}

void print_hex_serial(UINT64 val) {
    char hex_chars[] = "0123456789ABCDEF";
    for (int i = 60; i >= 0; i -= 4) {
        outb(0x3F8, hex_chars[(val >> i) & 0xF]);
    }
}

#define EFI_PAGE_SIZE 4096

void print_memory_stats(EFI_SYSTEM_TABLE* st) {
    UINTN map_size = 0;
    EFI_MEMORY_DESCRIPTOR* map = NULL;
    UINTN map_key;
    UINTN descriptor_size;
    UINT32 descriptor_version;

    // get buffer size
    st->BootServices->GetMemoryMap(&map_size, NULL, &map_key, &descriptor_size,
                                   &descriptor_version);
    map_size += (2 * descriptor_size);
    st->BootServices->AllocatePool(EfiLoaderData, map_size, (VOID**)&map);

    // get actual map
    if (st->BootServices->GetMemoryMap(&map_size, map, &map_key,
                                       &descriptor_size,
                                       &descriptor_version) != EFI_SUCCESS) {
        print_serial("ERROR: Failed to get memory map\r\n");
        return;
    }

    print_serial("\r\n--- DETAILED MEMORY MAP START ---\r\n");
    print_serial("TYPE | PHYSICAL START | PAGES | ATTRIBUTES\r\n");

    UINT64 total_ram = 0;
    UINT64 free_ram = 0;
    UINTN entries = map_size / descriptor_size;

    for (UINTN i = 0; i < entries; i++) {
        EFI_MEMORY_DESCRIPTOR* d =
            (EFI_MEMORY_DESCRIPTOR*)((UINT8*)map + (i * descriptor_size));

        // print type (0-14)
        print_hex_serial(d->Type);
        print_serial(" | ");

        // print Physical Start Address
        print_hex_serial(d->PhysicalStart);
        print_serial(" | ");

        // print Number of Pages
        print_hex_serial(d->NumberOfPages);
        print_serial(" | ");

        // print Attributes
        print_hex_serial(d->Attribute);
        print_serial("\r\n");

        UINT64 size = d->NumberOfPages * EFI_PAGE_SIZE;
        total_ram += size;
        if (d->Type == EfiConventionalMemory) {
            free_ram += size;
        }
    }

    print_serial("--- DETAILED MEMORY MAP END ---\r\n");

    // raw page count is often more accurate for debugging
    print_serial("Free Pages: ");
    print_hex_serial(free_ram / 4096);
    print_serial("\r\n");

    // MB (ensure 64-bit math)
    UINT64 free_mib = (free_ram) / (1024 * 1024);
    print_serial("Free MiB: ");
    print_hex_serial(free_mib);
    print_serial("\r\n");

    // clean up pool
    st->BootServices->FreePool(map);
}

EFI_STATUS EFIAPI efi_main(EFI_HANDLE ImageHandle,
                           EFI_SYSTEM_TABLE* SystemTable) {
    EFI_BOOT_SERVICES* bs = SystemTable->BootServices;
    EFI_GRAPHICS_OUTPUT_PROTOCOL* gop = NULL;
    EFI_GUID gop_guid = EFI_GRAPHICS_OUTPUT_PROTOCOL_GUID;

    print_serial("Initializing Full Font Console...\r\n");
    EFI_STATUS status = bs->LocateProtocol(&gop_guid, NULL, (VOID**)&gop);

    if (status == EFI_SUCCESS && gop != NULL) {
        UINT32* fb = (UINT32*)(UINTN)gop->Mode->FrameBufferBase;
        UINT32 stride = gop->Mode->Info->PixelsPerScanLine;
        UINT32 height = gop->Mode->Info->VerticalResolution;
        UINT32 width = gop->Mode->Info->HorizontalResolution;

        // clear screen to Midnight Blue
        for (UINT32 i = 0; i < (stride * height); i++) {
            fb[i] = 0x00000022;
        }

        print_string(fb, 20, 20, "OSCA x64", 0x00FFFF00, stride);
        for (int i = 0; i < 300; i++) {
            fb[30 * stride + 20 + i] = 0x00555555;
        }

        // hardware Diagnostics
        print_string(fb, 20, 50, "STATUS: GOP PROTOCOL ACTIVE", 0x0000FF00,
                     stride);
        print_string(fb, 20, 65, "FB BASE: ", 0x00FFFFFF, stride);
        print_hex_screen(fb, 100, 65, gop->Mode->FrameBufferBase, 0x0000FFFF,
                         stride);

        print_string(fb, 20, 80, "RES: ", 0x00FFFFFF, stride);
        print_hex_screen(fb, 100, 80, (UINT64)width, 0x00FF8800, stride);
        print_string(fb, 240, 80, "x", 0x00FFFFFF, stride);
        print_hex_screen(fb, 250, 80, (UINT64)height, 0x00FF8800, stride);

        // character test
        print_string(fb, 20, 110, "ASCII TEST: !\"#$%&'()*+,-./0123456789",
                     0x00CCCCCC, stride);
        print_string(fb, 20, 125, "LOWERCASE: abcdefghijklmnopqrstuvwxyz",
                     0x00CCCCCC, stride);
        print_string(fb, 20, 140, "UPPERCASE: ABCDEFGHIJKLMNOPQRSTUVWXYZ",
                     0x00CCCCCC, stride);

        print_serial("Console Rendered Successfully.\r\n");

        print_memory_stats(SystemTable);
    }

    while (1) {
        __asm__("hlt");
    }

    return EFI_SUCCESS;
}
